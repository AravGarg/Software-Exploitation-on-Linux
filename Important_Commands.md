### For a fixed libc:  
target=process('./baby_boi',env={"LD_PRELOAD":"/lib/x86_64-linux-gnu/libc.so.6"})

### To define libc as a variable:  
libc=ELF('path/to/libc')

### To find the base address of libc given the address of a function in libc(say printf)  
base=printf_libc-libc.symbols['printf']

### To find the offset of a string in libc,say "/bin/sh",  
bin_sh=libc.search("/bin/sh").next()

### To find plt entry in an elf:  
elf.symbols["puts"]

### to find got entry in an elf:  
elf.got["puts"]

### to get pointers to pointers to...., use search-pattern in gdb-gef.

### To get gadget of execve("/bin/sh"):  
one_gadget /path/of/libc  
try all given gadgets

### objdump  
objdump -t Simple_login | grep go_shell --> start address of go_shell function  
objdump -s -j .dtors arbwrite --> dtor list of arbwrite  
objdump -R ropesourasrex --> GOT table entries  
objdump -x ropasaurusrex --> shows all sections of the process  
objdump -d name_of_libc_file | grep read --> offset for read() in libc  
objdump -d ropasaurasrex --> full dissasembly 

### strings -t x -a /path/of/libc | grep "/bin/sh" --> offset of the string "/bin/sh" in libc

### ldd ropasaurusrex -->  
gives list of libraries used by the program ropasaurusrex , use this to get name and address of libc file, with ASLR this is different every time.

### gdb-peda  
(gdb-peda) run < payload  
(gdb-peda) run `cat payload`  
(gdb-peda) info file --> entry point  
(gdb-peda) find "/bin/sh" libc --> gives address of /bin/sh in libc (memory mapped region)  
(gdb-peda) p system --> address of system()  
(gdb-peda) vmmap - shows memory maps of the entire process, i.e stack,heap,libc,binary's memory. stack,heap,libc will change if aslr is on.binary's memory will change if pie is on. Use this to find a location in memory which is writeable. This also gives the version of libc being used.

###  
Execute int 0x80 on x86 and syscall on x86-64  to alert the kernel you want to perform a system call.

Look up the number corresponding to the system call in /usr/include/x86_64-linux-gnu/asm/unistd_64.h for x86-64 and /usr/include/x86_64-linux-gnu/asm/unistd_32.h for x86.

Place system call number in eax/rax, and arguments in ebx/rdi,ecx/rsi,edx/rdx,r10,r8,r9… etc in the order they appear in the corresponding man page.  
Arguments for x64 are put in rdi,rsi,rdx,rcx,r8,r9. Remaining on the stack.

readelf -l ropasaurusrex --> similar to info file in gdb.

gdb basic_vuln core --> debug dumped core after seg fault

(cat payload;cat)|./Simple_login --> The unix pipe “|” is to redirect output of our command (cat payload;cat) and use it as 
the input for simple_login. We have to put the extra “cat” in the command to echo Commands to the shell we will spawn, otherwise an EOF is sent and the shell closes immediately before we can actually execute any programs.   

wc hello.shellcode

perl -e ('print "\x90"*(64-34)';cat hello.shellcode) | cat > payload

./Simple_login < payload2

./Simple_login `cat payload2`

ulimit -c unlimited --> dump core after segfault

gcc -fno-stack-protector --> disables SSP(Stack Smashing Protection)  
gcc -z execstack --> disables NX  
perl -e 'printf"A"x72;print"\x12\x34\x56\x78"' > payload   
echo `python -c 'print"A"*200'`

xxd -g 1 payload

tcc -g -o Simple_login Simple_login.c --> -g for gdb, tcc for tiny c compiler(without optimizations)

print "%d" $esp-$ebp

/proc/sys/kernel/randomize_va_space controls ASLR  
sudo bash -c "echo 0 > /proc/sys/kernel/randomize_va_space" disables ASLR temporarily

```https://bitvijays.github.io/LFC-BinaryExploitation.html```



